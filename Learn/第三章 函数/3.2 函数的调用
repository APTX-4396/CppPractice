3.2.1 函数调用的语法形式

为实现操作功能而单独编写的函数能单独编译，但不能自动运行，必须被其他函数调用才能运行
通常把其他函数的函数称为主调函数，被其他函数调用的函数称为被调函数

函数调用的语句形式如下：
函数名（实际参数1，实际参数2，实际参数n）；

一个函数在被调用语句中，其参数称为实际参数（简称为实参），函数调用中的实参不需要加数据类型，实参的个数、类型、顺序要和函数定义时的形参一一对应
动手敲一下更有助于理解~：实参就是你在主函数中定义好了的变量，数据类型一开始就确定了所以在函数引用时不需要加数据类型

对有参函数的调用，实际参数可以是常数、变量或其他构造类型数据及表达式，各实参之间用逗号分隔。对无参函数调用时则无实际参数

定义有参函数时，形式参数并没有具体数据值，在被主调函数调用时，主调函数也必须给具体数据（实参），将实参值依次传递给相应的形参
啊..我随便举个例子帮忙理解一下（虽然有可能写错
int sum(int x,int y)
{
int s;
s=x+y;
return s;
}
void main()
{
int a=;
int b=;
int SUM;
sum=sum(a,b);
}
没有打印,大抵如此，第27行怎么用的函数就是将实参值传递给自定义函数中的形参
C语言老师是这么跟我说的：虚实结合（我也不知道这是咋联想到的）
可惜 我上课不怎么听（又被C语言期末分数气炸了

3.2.2 函数调用的过程

在C++语言中,程序运行总是从main()函数开始,按函数体中语句的逻辑顺序向后依次执行
如遇到函数调用,就转去执行被调用的函数
被调用的函数执行完毕,又返回到主调函数中继续向下执行

函数调用过程可简单比喻为查字典,如果在看书时碰到一个不认识的字就会停下来翻阅字典,查完字典后又接着往后看
(不愧是工科人写的书,这比喻看了让我抠脚
(其实可以比喻成做菜,你做菜到哪一步就用哪一个工具,切菜要用刀具,煮要用到锅,每一步的工具就相当于一个函数(function)

调用过程:
Ⅰ函数调用,把实参的值传递给形参
Ⅱ执行被调用函数的函数体,形参用所获得的数值进行运算
Ⅲ通过return语句将被调用函数的运算结果输出给主调函数
Ⅳ返回到主调函数的函数调用表达式位置,继续后续语句的执行

3.2.3 函数的传值调用

在C++语言中,调用有参函数时,是通过实参向形参传值的,按调用方式可分为传值调用和引用调用

形参只能在被调函数中使用,实参只能在主调函数中使用
形参是没有值的变量,发生函数调用时,主调函数把实参的值传递给被调函数的形参,从而实现主调函数向被调函数的数据传送
函数的调用过程也成为值的单向传递,是实参到形参的传递
因此在传递时,实参必须已经有值,并且实参的个数及类型必须与形参的个数及类型完全一致
函数调用时实参数值按顺序依次传递给相应的形参

Ⅰ主调函数为实参赋值,将实参值存放到内存中专门存放临时变量(又称为动态局部变量)的区域中.这块存储区域称为堆栈
Ⅱ当参数传递时,主调函数把堆栈中的实参值赋值一个备份给被调函数的形参
Ⅲ被调函数使用形参进行功能运算
Ⅳ被调函数把运算结果(函数返回值)存放到堆栈中,由主调函数取回.此时,形参所占用的存储空间被系统收回.注意,此时实参值占用的存储单元还在被继续使用

(为什么堆栈这个东西会这么早出现啊.这里暂时就看个乐呵,知道实参存在堆栈,堆栈备份实参值,形参引用堆栈备份就行了罢,大概,我也没学到堆栈那边的东西呢

函数的传值调用过程中,形参相当于实参的一个副本,在被调函数中修改形参的值是不影响原实参变量值的
翻译成人话:函数里面的形参值随你咋折腾,主函数里面的实参值都不会被你折腾到

3.2.4

1.引用的概念

在C++中，引用是处理变量的一种方法。应用这种方式可以简化很多语法，使一些原本难以实现的问题得到解决。系统不需要为引用负担额外的开销，节省了内存空间

引用是已存在的变量的一个别名，对引用型变量的操作实际上就是对被引用变量的操作

定义一个引用型变量的语法形式如下：
数据类型 &引用变量名 = 被引用变量名；

eg：
int a;
int &ra = a;//定义引用变量ra，它是变量a的引用，a是被引用变量
说明：
Ⅰ“&”是引用运算符，注意与后面章节中的指针取址运算符区别
Ⅱ引用变量的数据类型应与被引用变量的类型相同
Ⅲ声明引用时，必须同时对其进行初始化
Ⅳ引用完毕后，相当于被引用变量名有两个名称，ra相当于a的别名（绰号）。对ra的任何操作就是对a的操作。且不能再把该引用名作为其他变量名的别名
Ⅴ声明一个引用，不是新定义了一个变量，它不占用存储单元，系统也不给引用分配存储单元
Ⅵ引用运算符&仅在说明一个引用型变量时使用，引用型变量被说明之后，就不能再带&，只需直接使用变量名

C语言好像没这东西，我之前脑子里引用的概念就是把赋值的符号使用..这引用变量和被引用变量有啥区别，直接使用a不好吗
引用变量和被引用变量具有相同的地址，共用同一个存储单元.
知道归知道这个道理，但我很好奇这个概念能用在哪里

#include<iostream>
using namespace std;
void main()
{
	int a;
	int& ra = a;
	a = 3;
	cout << "设a=3时，ra=" << ra << endl;
	ra = 8;
	cout << "设ra=8时，a=" << a << endl;
}

从上例来看，改变了a和ra中任意一个的值，另一个都会随之变动。（但为什么不直接就用被引用变量而非要舍近求远整一个引用的概念？）

2.引用作函数的参数

eg3-7 使用引用参数，实现两数据值的交换

#include<iostream>
using namespace std;
void swap(int& rx, int& ry);
void main()
{
	int x = 5, y = 6;
	cout << "交换前：x=" << x << "y=" << y << endl;
	swap(x, y);
	cout << "交换后：x=" << x << "y=" << y << endl;
}
void swap(int& rx, int& ry)
{
	int temp = rx;
	rx = ry;
	ry = temp;
}

程序说明：
程序执行第8行swap（x，y）语句时，程序的流程转到swap（）函数
函数使用引用形参，由于形参rx与x共用一个存储单元，形参ry与y共用一个存储单元，所以传递的参数实质就是变量x、y本身
在被调函数swap（）中，rx和ry的值进行了交换
main函数中x、y的值也随之发生了交换

eg3-8 编写一个函数，一个参数以值形式传递，另一个参数以引用形式传递，验证值传递和引用传递的区别

#include<iostream>
using namespace std;
void fun(int, int&);
int main()
{
	int a = 22, b = 44;
	cout << "初始值：a=" << a << ", b=" << b << endl;
	fun(a, b);
	cout << "参数传递后：fun（a，b），a=" << a << ", b=" << b << endl;
	return 0;
}
void fun(int x, int& y)
{
	x = 88;
	y = 99;
}

程序说明：
fun（a，b）调用通过值传递将a传递给x，通过引用传递把b传递给y
所以x是一个局部变量，被赋值为a的值22，y是变量b的别名
函数将88赋给x，但是不对a产生影响
但是当函数将99赋给y时，它确实将99赋给了b，因为y是b的别名
因此当函数调用结束后，a的值仍为其初值22，而b有了一个新的数值99
实参a是只读的，而实参b是可读写的

为啥就不能写成人话非要让我来翻译：
在上述程序中，a和x是两个不同的变量，只是x在函数的调用中被赋值为了a，是x在函数中进行运算变成88，而不是a在进行运算，所以a=22没啥毛病
y是引用变量，b是被引用变量，y和b共用同一个存储单元，一荣俱荣一损俱损，当y要进行变化时b也要进行相同的运算，所以b在函数中被赋值为99

eg 3-9 编写一个计算圆的面积和周长的函数，通过引用返回计算后的面积和周长

#include<iostream>
using namespace std;
void ComCircle(double&, double&, double);
int main()
{
	double r, a, c;
	cout << "请输出圆的半径：";
	cin >> r;
	ComCircle(a, c, r);
	cout << "面积=" << a << ", 周长=" << c << endl;
	return 0;
}
void ComCircle(double& area, double& circum, double r)
{
	const double PI = 3.141592653589793;
	area = PI * r * r;
	circum = 2 * PI * r;
}

程序说明：
通常函数通过return语句只能有一个返回值，但是如果使用引用形参，就可以返回多于一个的返回值

3.2.5 函数的嵌套调用

C++语言中不允许函数的嵌套定义，但允许被调用的函数又调用另一个函数。这种调用就称为嵌套调用
